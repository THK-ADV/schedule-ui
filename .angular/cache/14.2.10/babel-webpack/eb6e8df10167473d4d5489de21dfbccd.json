{"ast":null,"code":"import { EMPTY } from 'rxjs';\nimport { groupBy, mapGroup } from '../../utils/group-by';\nimport { map, mergeAll, switchMap, toArray } from 'rxjs/operators';\nimport { describeExamRegShort, describeLanguage, describeSeason } from '../../utils/describe';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../../http/submodule-api.service\";\nimport * as i2 from \"../../http/examination-regulation-api.service\";\nexport let LecturerModuleService = /*#__PURE__*/(() => {\n  class LecturerModuleService {\n    constructor(submoduleHttp, examHttp) {\n      this.submoduleHttp = submoduleHttp;\n      this.examHttp = examHttp;\n      this.lecturerModules = id => {\n        const submodules$ = this.submoduleHttp.submodules([{\n          key: 'lecturer',\n          value: id\n        }]); // TODO add backend support\n        const group = xs => groupBy(xs, x => x.module.id);\n        const exams$ = mid => this.examHttp.examinationRegulations([{\n          key: 'module',\n          value: mid\n        }]); // TODO add backend support\n        const makeLecturerModule = (submodules, module) => exams => ({\n          submodules,\n          module,\n          exams\n        });\n        return submodules$.pipe(map(group), switchMap(xs => mapGroup(xs, (k, v) => {\n          if (v.length === 0) {\n            return EMPTY;\n          }\n          return exams$(k).pipe(map(makeLecturerModule(v, v[0].module)));\n        })), mergeAll(), toArray());\n      };\n      this.columns = () => [{\n        attr: 'label',\n        title: 'Bezeichnung'\n      }, {\n        attr: 'abbreviation',\n        title: 'Abkürzung'\n      }, {\n        attr: 'recommendedSemester',\n        title: 'Fachsemester'\n      }, {\n        attr: 'credits',\n        title: 'ECTS'\n      }, {\n        attr: 'language',\n        title: 'Sprache'\n      }, {\n        attr: 'season',\n        title: 'Angeboten in'\n      }, {\n        attr: 'descriptionUrl',\n        title: 'Modulbeschreibung'\n      }, {\n        attr: 'module',\n        title: 'Modulzugehörigkeit'\n      }, {\n        attr: 'moduleExam',\n        title: 'Angeboten in Studiengängen'\n      }];\n      this.tableContent = (lm, submodule, attr) => {\n        switch (attr) {\n          case 'label':\n            return submodule.label;\n          case 'abbreviation':\n            return submodule.abbreviation;\n          case 'recommendedSemester':\n            return submodule.recommendedSemester.toString();\n          case 'credits':\n            return submodule.credits.toString();\n          case 'language':\n            return describeLanguage(submodule.language);\n          case 'season':\n            return describeSeason(submodule.season);\n          case 'descriptionUrl':\n            return submodule.descriptionUrl;\n          case 'moduleExam':\n            return lm.exams.map(describeExamRegShort).join(',');\n          default:\n            return '???';\n        }\n      };\n      this.sortingDataAccessor = (a, attr) => '';\n      this.singleRow = attr => attr === 'module';\n      this.singleRowContent = (lm, attr) => {\n        switch (attr) {\n          case 'module':\n            return `${lm.module.abbreviation} (${lm.module.credits} ECTS)`;\n          default:\n            return '???';\n        }\n      };\n      this.createWPF = () => {};\n    }\n  }\n  LecturerModuleService.ɵfac = function LecturerModuleService_Factory(t) {\n    return new (t || LecturerModuleService)(i0.ɵɵinject(i1.SubmoduleApiService), i0.ɵɵinject(i2.ExaminationRegulationApiService));\n  };\n  LecturerModuleService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: LecturerModuleService,\n    factory: LecturerModuleService.ɵfac,\n    providedIn: 'root'\n  });\n  return LecturerModuleService;\n})();","map":null,"metadata":{},"sourceType":"module"}